<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ghi ch√∫ Kanban</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .task-list-scrollable {
            min-height: 200px;
            overflow-y: auto;
            height: calc(100vh - 110px - 40px); /* Mobile: VP - Header - Tabs - Padding/Margin */
        }
        @media (min-width: 768px) { /* md breakpoint and up */
            .task-list-scrollable {
                height: calc(100vh - 120px); /* Desktop: VP - Header - AddBtn - Margins/Paddings */
            }
        }

        .task {
            cursor: grab;
            touch-action: manipulation;
            border-left-width: 4px;
            border-left-color: transparent;
            transition: border-color 0.3s ease-in-out;
        }
        .task-attachment-preview {
            max-width: 100%;
            max-height: 100px;
            object-fit: cover;
            border-radius: 0.25rem;
            margin-top: 8px;
            border: 1px solid #e2e8f0;
        }
        .task-attachment-link {
            display: inline-block;
            margin-top: 8px;
            font-size: 0.8rem;
            color: #2b6cb0;
            text-decoration: underline;
        }
        .task-attachment-link:hover { color: #2c5282; }

        .task:active { cursor: grabbing; }
        .dragging { opacity: 0.5; border: 2px dashed #cbd5e0; }
        .drag-over { border: 2px dashed #3b82f6; background-color: #eff6ff; }
        #confettiCanvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 9999;
        }
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #fefefe; margin: auto; padding: 20px;
            border: 1px solid #888; width: 80%; max-width: 500px;
            border-radius: 8px;
        }
        #archivedTasksModal .modal-content { max-width: 700px; }
        #archivedTasksList { max-height: 60vh; overflow-y: auto; }
        .archived-task-item {
            padding: 0.75rem; border-bottom: 1px solid #e2e8f0;
            display: flex; justify-content: space-between; align-items: center;
        }
        .archived-task-item:last-child { border-bottom: none; }
        .archived-task-item p { margin: 0; flex-grow: 1; margin-right: 1rem; word-break: break-word; }
        .archived-task-item .actions button {
            font-size: 0.75rem; padding: 0.25rem 0.5rem; margin-left: 0.5rem; white-space: nowrap;
        }
        .close-button {
            color: #aaa; float: right; font-size: 28px; font-weight: bold;
        }
        .close-button:hover, .close-button:focus {
            color: black; text-decoration: none; cursor: pointer;
        }

        .task-list-scrollable::-webkit-scrollbar, #archivedTasksList::-webkit-scrollbar { width: 8px; }
        .task-list-scrollable::-webkit-scrollbar-track, #archivedTasksList::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .task-list-scrollable::-webkit-scrollbar-thumb, #archivedTasksList::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        .task-list-scrollable::-webkit-scrollbar-thumb:hover, #archivedTasksList::-webkit-scrollbar-thumb:hover { background: #555; }

        #appContentContainer { display: none; }
        .auth-form-container {
            max-width: 400px; margin: 2rem auto; padding: 2rem;
            background-color: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .task-actions button, .task-move-actions button {
            margin-left: 4px; padding: 4px; font-size: 0.75rem;
            border: 1px solid transparent; border-radius: 0.25rem;
            display: flex; align-items: center; justify-content: center;
            width: 28px; height: 28px;
        }
        .task-actions button:hover, .task-move-actions button:hover { opacity: 0.8; }
        .task-move-actions {
            margin-top: 6px; width: 100%; display: flex;
            justify-content: flex-start; gap: 6px;
        }
        .move-btn-todo { background-color: #fecaca20; color: #b91c1c; border-color: #fca5a580; }
        .move-btn-inprogress { background-color: #fed7aa20; color: #c2410c; border-color: #fdba7480; }
        .move-btn-done { background-color: #bbf7d020; color: #15803d; border-color: #86efac80; }
        .archive-btn { background-color: #e2e8f020; color: #4a5568; border-color: #cbd5e080; }

        .task-actions .edit-btn { color: #3b82f6; }
        .task-actions .delete-btn { color: #ef4444; }
        .task-actions .edit-btn:hover { background-color: #dbeafe; }
        .task-actions .delete-btn:hover { background-color: #fee2e2; }

        .task-due-date { font-size: 0.75rem; color: #4a5568; margin-top: 4px; }
        .due-date-passed { color: #e53e3e; font-weight: 500; }
        .due-date-today { color: #dd6b20; font-weight: 500; }

        .priority-low { border-left-color: #68d391; }
        .priority-medium { border-left-color: #f6e05e; }
        .priority-high { border-left-color: #fc8181; }

        .priority-indicator {
            font-size: 0.7rem; padding: 1px 4px; border-radius: 4px;
            margin-top: 4px; display: inline-block; color: white;
        }
        .indicator-low { background-color: #68d391; }
        .indicator-medium { background-color: #f6e05e; color: #4a5568; }
        .indicator-high { background-color: #fc8181; }

        #appHeader {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.3rem 0.75rem; margin-bottom: 0.75rem; height: 40px;
        }
        #appHeader h1 {
            font-size: 1.25rem; font-weight: 600; margin: 0; color: #2d3748;
        }
        #headerUserControls { display: flex; align-items: center; gap: 0.5rem; }
        #userInfo { display: none !important; }
        .header-icon-btn {
            background-color: transparent; color: #4a5568; padding: 0.25rem;
            border: none; border-radius: 9999px; display: flex;
            align-items: center; justify-content: center; width: 32px; height: 32px;
        }
        .header-icon-btn:hover { background-color: #edf2f7; color: #1a202c; }
        .header-icon-btn svg { width: 18px; height: 18px; }

        #addTaskBtnContainerDesktop {
            height: 40px; align-items: center; justify-content: flex-start;
            gap: 0.5rem; margin-bottom: 0.75rem;
        }
        #addTaskBtn, #viewArchivedBtnDesktop {
            padding: 0.4rem 0.8rem; font-size: 0.85rem;
        }
        #fabAddTaskBtn {
            width: 56px; height: 56px; font-size: 2rem; line-height: 1;
        }
        .empty-column-placeholder {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 150px; border: 2px dashed #cbd5e0; border-radius: 0.375rem;
            color: #718096; font-style: italic; margin-top: 1rem;
        }
        .empty-column-placeholder svg {
            width: 32px; height: 32px; margin-bottom: 0.5rem; opacity: 0.6;
        }
        .task-actions svg, .task-move-actions svg { width: 16px; height: 16px; }
        #attachmentPreview {
            max-width: 100px; max-height: 100px; margin-top: 5px;
            border: 1px solid #ccc; display: none;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 20px; height: 20px;
            animation: spin 1s linear infinite; display: none; margin-left: 10px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .column-header-count {
            font-size: 0.875rem; color: #4a5568; background-color: #e2e8f0;
            padding: 0.125rem 0.5rem; border-radius: 9999px; margin-left: 0.5rem;
        }

        /* Tab Styles Updated */
        #kanbanTabs {
            border-bottom: 1px solid #e2e8f0; /* Keep this for overall structure */
            background-color: transparent; /* Tab bar transparent, body bg will show or tabs will cover */
            /* overflow-x: auto; /* Optional: if tabs ever overflow horizontally */
        }
        .tab-button {
            padding: 0.75rem 1rem;
            font-size: 0.875rem;
            font-weight: 500; /* Base font weight */
            /* color and background-color will be set by JS */
            transition: color 0.2s ease, background-color 0.2s ease;
            flex-grow: 1;
            text-align: center;
            cursor: pointer;
            border-radius: 6px 6px 0 0; /* Rounded top corners for tab look */
            margin-right: 2px; /* Small gap between tabs */
            border-bottom: none; /* Remove explicit bottom border, background indicates active */
        }
        .tab-button:last-child {
            margin-right: 0;
        }
        /* .active-tab class is no longer used for primary styling of active state, JS handles it */

        .kanban-main-column { /* Default hidden on mobile, JS adds 'block' or 'hidden' */ }
        @media (max-width: 767px) { /* Below md breakpoint */
            .kanban-main-column { display: none; /* Default hide columns on mobile */ }
            .kanban-main-column.active-column-mobile { display: block !important; /* Show active column */ }
            #appContent { display: block; /* Remove grid on mobile */ }
        }

        /* Bottom Sheet Styles */
        #moveTaskBottomSheet {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: white; border-top-left-radius: 16px; border-top-right-radius: 16px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.15); transform: translateY(100%);
            transition: transform 0.3s ease-out; z-index: 1050; padding: 16px; display: none;
        }
        #moveTaskBottomSheet.active { transform: translateY(0); display: block; }
        #bottomSheetOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.4); z-index: 1040; display: none;
        }
        #bottomSheetOverlay.active { display: block; }
        #bottomSheetOptionsList button {
            display: block; width: 100%; padding: 12px 16px; text-align: left;
            border: none; background: none; font-size: 1rem; color: #2d3748;
            border-bottom: 1px solid #edf2f7;
        }
        #bottomSheetOptionsList button:last-child { border-bottom: none; }
        #bottomSheetOptionsList button:hover { background-color: #f7fafc; }
        #bottomSheetCloseBtn {
            display: block; width: 100%; padding: 12px 16px; margin-top: 10px;
            text-align: center; border: none; background-color: #e2e8f0;
            color: #4a5568; border-radius: 8px; font-size: 1rem; font-weight: 500;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 text-slate-800">
    <div class="container mx-auto p-2 md:p-1">
        <header id="appHeader" style="display: none;">
            <button id="viewArchivedBtnMobile" class="header-icon-btn md:hidden" title="Xem ghi ch√∫ ƒë√£ l∆∞u tr·ªØ">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99" /></svg>
            </button>
            <h1>Ghi ch√∫</h1>
            <div id="headerUserControls">
                <div id="userInfo"></div>
                <button id="logoutBtn" class="header-icon-btn hidden" title="ƒêƒÉng xu·∫•t">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" fill="currentColor">
                        <path d="M377.9 105.9L500.7 228.7c7.2 7.2 11.3 17.1 11.3 27.3s-4.1 20.1-11.3 27.3L377.9 406.1c-6.4 6.4-15 9.9-24 9.9c-18.7 0-33.9-15.2-33.9-33.9l0-62.1-128 0c-17.7 0-32-14.3-32-32l0-64c0-17.7 14.3-32 32-32l128 0 0-62.1c0-18.7 15.2-33.9 33.9-33.9c9 0 17.6 3.6 24 9.9zM160 96L96 96c-17.7 0-32 14.3-32 32l0 256c0 17.7 14.3 32 32 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-64 0c-53 0-96-43-96-96L0 128C0 75 43 32 96 32l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32z"/>
                    </svg>
                </button>
            </div>
        </header>

        <div id="loginFormContainer" class="auth-form-container">
            <h2 class="text-2xl font-semibold text-slate-700 mb-6 text-center">ƒêƒÉng nh·∫≠p</h2>
            <input type="email" id="emailInput" class="w-full p-3 border border-slate-300 rounded-lg mb-4 focus:ring-2 focus:ring-sky-500 focus:border-sky-500" placeholder="Email">
            <input type="password" id="passwordInput" class="w-full p-3 border border-slate-300 rounded-lg mb-6 focus:ring-2 focus:ring-sky-500 focus:border-sky-500" placeholder="M·∫≠t kh·∫©u">
            <button id="loginBtn" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out mb-3">
                ƒêƒÉng nh·∫≠p
            </button>
            <button id="showRegisterBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out">
                ƒêƒÉng k√Ω
            </button>
            <p id="authError" class="text-red-500 text-sm mt-3 text-center"></p>
        </div>

        <div id="registerFormContainer" class="auth-form-container" style="display: none;">
            <h2 class="text-2xl font-semibold text-slate-700 mb-6 text-center">ƒêƒÉng k√Ω</h2>
            <input type="email" id="registerEmailInput" class="w-full p-3 border border-slate-300 rounded-lg mb-4 focus:ring-2 focus:ring-sky-500 focus:border-sky-500" placeholder="Email">
            <input type="password" id="registerPasswordInput" class="w-full p-3 border border-slate-300 rounded-lg mb-6 focus:ring-2 focus:ring-sky-500 focus:border-sky-500" placeholder="M·∫≠t kh·∫©u (t·ªëi thi·ªÉu 6 k√Ω t·ª±)">
            <button id="registerBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out mb-3">
                ƒêƒÉng k√Ω
            </button>
            <button id="showLoginBtn" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out">
                Quay l·∫°i ƒêƒÉng nh·∫≠p
            </button>
            <p id="registerAuthError" class="text-red-500 text-sm mt-3 text-center"></p>
        </div>

        <div id="appContentContainer">
            <div id="addTaskBtnContainerDesktop" class="hidden md:flex">
                <button id="addTaskBtn" class="bg-sky-500 hover:bg-sky-600 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out">
                    Th√™m ghi ch√∫
                </button>
                <button id="viewArchivedBtnDesktop" class="ml-2 bg-slate-500 hover:bg-slate-600 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out">
                    Xem L∆∞u Tr·ªØ
                </button>
            </div>

            <div id="kanbanTabs" class="flex md:hidden">
                <button class="tab-button" data-status="todo">C·∫ßn l√†m</button>
                <button class="tab-button" data-status="inprogress">ƒêang l√†m</button>
                <button class="tab-button" data-status="done">Ho√†n th√†nh</button>
            </div>

            <div id="appContent" class="md:grid md:grid-cols-3 md:gap-4 md:gap-6">
                <div id="todo-column-wrapper" class="kanban-main-column bg-rose-100 p-4 rounded-lg shadow-lg" data-status="todo">
                    <h2 class="text-xl font-semibold text-rose-700 mb-4 border-b-2 border-rose-300 pb-2 flex justify-between items-center">
                        <span>C·∫ßn l√†m</span>
                        <span id="todo-count" class="column-header-count">0</span>
                    </h2>
                    <div id="todo-tasks" class="space-y-3 task-list min-h-[100px] task-list-scrollable"></div>
                </div>
                <div id="inprogress-column-wrapper" class="kanban-main-column bg-amber-100 p-4 rounded-lg shadow-lg" data-status="inprogress">
                    <h2 class="text-xl font-semibold text-amber-700 mb-4 border-b-2 border-amber-300 pb-2 flex justify-between items-center">
                        <span>ƒêang l√†m</span>
                        <span id="inprogress-count" class="column-header-count">0</span>
                    </h2>
                    <div id="inprogress-tasks" class="space-y-3 task-list min-h-[100px] task-list-scrollable"></div>
                </div>
                <div id="done-column-wrapper" class="kanban-main-column bg-green-100 p-4 rounded-lg shadow-lg" data-status="done">
                    <h2 class="text-xl font-semibold text-green-700 mb-4 border-b-2 border-green-300 pb-2 flex justify-between items-center">
                        <span>Ho√†n th√†nh</span>
                        <span id="done-count" class="column-header-count">0</span>
                    </h2>
                    <div id="done-tasks" class="space-y-3 task-list min-h-[100px] task-list-scrollable"></div>
                </div>
            </div>
        </div>

        <button id="fabAddTaskBtn" class="block md:hidden fixed bottom-6 right-6 bg-sky-500 hover:bg-sky-600 text-white rounded-full shadow-lg flex items-center justify-center z-50" title="Th√™m ghi ch√∫ m·ªõi">
            +
        </button>
    </div>

    <div id="taskModal" class="modal">
        <div class="modal-content">
            <span id="closeModalBtn" class="close-button">&times;</span>
            <h3 id="modalTitle" class="text-2xl font-semibold mb-6 text-slate-700">Th√™m ghi ch√∫ m·ªõi</h3>

            <label for="taskInput" class="block text-sm font-medium text-slate-700 mb-1">N·ªôi dung ghi ch√∫:</label>
            <input type="text" id="taskInput" class="w-full p-3 border border-slate-300 rounded-lg mb-4 focus:ring-2 focus:ring-sky-500 focus:border-sky-500" placeholder="Nh·∫≠p n·ªôi dung ghi ch√∫...">

            <label for="taskDueDateInput" class="block text-sm font-medium text-slate-700 mb-1">Ng√†y h·∫øt h·∫°n (T√πy ch·ªçn):</label>
            <input type="date" id="taskDueDateInput" class="w-full p-3 border border-slate-300 rounded-lg mb-4 focus:ring-2 focus:ring-sky-500 focus:border-sky-500">

            <label for="taskPriorityInput" class="block text-sm font-medium text-slate-700 mb-1">M·ª©c ƒë·ªô ∆∞u ti√™n:</label>
            <select id="taskPriorityInput" class="w-full p-3 border border-slate-300 rounded-lg mb-4 focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
                <option value="low">Th·∫•p</option>
                <option value="medium" selected>Trung b√¨nh</option>
                <option value="high">Cao</option>
            </select>

            <label for="taskAttachmentInput" class="block text-sm font-medium text-slate-700 mb-1">ƒê√≠nh k√®m (T√πy ch·ªçn):</label>
            <input type="file" id="taskAttachmentInput" class="w-full p-2 border border-slate-300 rounded-lg mb-1 focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
            <img id="attachmentPreview" src="#" alt="Xem tr∆∞·ªõc ·∫£nh ƒë√≠nh k√®m" class="mb-4"/>
            <div id="currentAttachmentInfo" class="text-sm text-slate-500 mb-4" style="display:none;">
                File hi·ªán t·∫°i: <a href="#" target="_blank" id="currentAttachmentLink"></a>
                <button id="removeAttachmentBtn" class="text-red-500 hover:text-red-700 text-xs ml-2">[X√≥a]</button>
            </div>

            <div class="flex justify-end items-center">
                <div id="uploadSpinner" class="loading-spinner"></div>
                <button id="saveTaskBtn" class="bg-sky-500 hover:bg-sky-600 text-white font-semibold py-2 px-5 rounded-lg shadow-md transition duration-150 ease-in-out">
                    L∆∞u
                </button>
            </div>
        </div>
    </div>

    <div id="archivedTasksModal" class="modal">
        <div class="modal-content">
            <span id="closeArchivedModalBtn" class="close-button">&times;</span>
            <h3 class="text-2xl font-semibold mb-6 text-slate-700">Ghi ch√∫ ƒë√£ l∆∞u tr·ªØ</h3>
            <div id="archivedTasksList" class="space-y-2">
                </div>
        </div>
    </div>

    <div id="bottomSheetOverlay"></div>
    <div id="moveTaskBottomSheet">
        <h4 class="text-lg font-semibold mb-3 text-slate-700">Di chuy·ªÉn ghi ch√∫ ƒë·∫øn:</h4>
        <div id="bottomSheetOptionsList">
            </div>
        <button id="bottomSheetCloseBtn" class="mt-4">H·ªßy</button>
    </div>

    <canvas id="confettiCanvas"></canvas>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import {
            getAuth,
            onAuthStateChanged,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            doc,
            updateDoc,
            deleteDoc,
            onSnapshot,
            query,
            where,
            orderBy,
            Timestamp,
            setLogLevel,
            getDocs
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
        import {
            getStorage,
            ref as storageRef,
            uploadBytes,
            getDownloadURL,
            deleteObject
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-storage.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDPEaExmwMz2mQWN_vDDTdziegQUfUrLaA",
            authDomain: "ghichucode.firebaseapp.com",
            projectId: "ghichucode",
            storageBucket: "ghichucode.firebasestorage.app",
            messagingSenderId: "105071769282",
            appId: "1:105071769282:web:9af172be73deb5267eed5b"
        };

        const appIdForPath = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        setLogLevel('debug');

        let currentUserId = null;
        let isAuthReady = false;
        let tasksUnsubscribe = null;
        let currentEditTaskId = null;
        let currentTaskDataForEdit = null;

        const confettiColors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722'];
        let confettiCanvas, confettiCtx, confettiParticles = [];

        function getTasksCollectionPath() {
            if (!currentUserId) return null;
            return `artifacts/${appIdForPath}/users/${currentUserId}/kanbanTasks`;
        };

        let loginFormContainer, registerFormContainer, emailInput, passwordInput, loginBtn, showRegisterBtn,
            registerEmailInput, registerPasswordInput, registerBtn, showLoginBtn, authError, registerAuthError,
            appHeader, logoutBtn, appContentContainer, appContent, addTaskBtnContainerDesktop, addTaskBtn, fabAddTaskBtn,
            taskModal, closeModalBtn, saveTaskBtn, taskInput, taskDueDateInput, taskPriorityInput,
            taskAttachmentInput, attachmentPreview, currentAttachmentInfo, currentAttachmentLink,
            removeAttachmentBtn, uploadSpinner, modalTitle,
            todoCountSpan, inprogressCountSpan, doneCountSpan,
            viewArchivedBtnDesktop, viewArchivedBtnMobile, archivedTasksModal, closeArchivedModalBtn, archivedTasksList,
            moveTaskBottomSheet, bottomSheetOverlay, bottomSheetOptionsList, bottomSheetCloseBtn,
            kanbanTabsContainer;
        let activeBottomSheetTaskId = null;
        let tabButtons = [];
        let columnWrappers = {};

        let columns = {};
        let columnElements = [];

        const iconArrowLeft = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg>`;
        const iconArrowRight = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>`;
        const iconCheck = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4.5 12.75l6 6 9-13.5" /></svg>`;
        const iconEdit = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" /></svg>`;
        const iconDelete = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.56 0c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0" /></svg>`;
        const iconArchive = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M20.25 7.5l-.625 10.632a2.25 2.25 0 01-2.247 2.118H6.622a2.25 2.25 0 01-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125V6.375c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v.001c0 .621.504 1.125 1.125 1.125z" /></svg>`;

        // Configuration for tab colors
        const tabColorConfigs = {
            todo: { bg: 'bg-rose-100', text: 'text-rose-700', name: 'C·∫ßn l√†m' },
            inprogress: { bg: 'bg-amber-100', text: 'text-amber-700', name: 'ƒêang l√†m' },
            done: { bg: 'bg-green-100', text: 'text-green-700', name: 'Ho√†n th√†nh' }
        };
        const inactiveTabConfig = {
            bg: 'bg-slate-200', // A light background for inactive tabs
            text: 'text-slate-600'  // Darker text for better contrast on light bg
        };
        let currentActiveMobileTabStatus = 'todo'; // Initialize
        const tabOrder = ['todo', 'inprogress', 'done'];

        // Swipe detection variables
        let touchStartX = 0;
        let touchEndX = 0;
        let touchStartY = 0;
        const swipeThreshold = 75; // Min distance (px) for a swipe action
        const swipeXThresholdForLock = 10; // Min X distance to consider it a horizontal gesture before locking Y scroll


        function initializeDOMReferencesAndEvents() {
            loginFormContainer = document.getElementById('loginFormContainer');
            registerFormContainer = document.getElementById('registerFormContainer');
            emailInput = document.getElementById('emailInput');
            passwordInput = document.getElementById('passwordInput');
            loginBtn = document.getElementById('loginBtn');
            showRegisterBtn = document.getElementById('showRegisterBtn');
            registerEmailInput = document.getElementById('registerEmailInput');
            registerPasswordInput = document.getElementById('registerPasswordInput');
            registerBtn = document.getElementById('registerBtn');
            showLoginBtn = document.getElementById('showLoginBtn');
            authError = document.getElementById('authError');
            registerAuthError = document.getElementById('registerAuthError');

            appHeader = document.getElementById('appHeader');
            logoutBtn = document.getElementById('logoutBtn');
            appContentContainer = document.getElementById('appContentContainer');
            appContent = document.getElementById('appContent');
            addTaskBtnContainerDesktop = document.getElementById('addTaskBtnContainerDesktop');
            addTaskBtn = document.getElementById('addTaskBtn');
            fabAddTaskBtn = document.getElementById('fabAddTaskBtn');

            taskModal = document.getElementById('taskModal');
            closeModalBtn = document.getElementById('closeModalBtn');
            saveTaskBtn = document.getElementById('saveTaskBtn');
            taskInput = document.getElementById('taskInput');
            taskDueDateInput = document.getElementById('taskDueDateInput');
            taskPriorityInput = document.getElementById('taskPriorityInput');
            taskAttachmentInput = document.getElementById('taskAttachmentInput');
            attachmentPreview = document.getElementById('attachmentPreview');
            currentAttachmentInfo = document.getElementById('currentAttachmentInfo');
            currentAttachmentLink = document.getElementById('currentAttachmentLink');
            removeAttachmentBtn = document.getElementById('removeAttachmentBtn');
            uploadSpinner = document.getElementById('uploadSpinner');
            modalTitle = document.getElementById('modalTitle');

            columns = {
                todo: document.getElementById('todo-tasks'),
                inprogress: document.getElementById('inprogress-tasks'),
                done: document.getElementById('done-tasks')
            };
            columnWrappers = {
                todo: document.getElementById('todo-column-wrapper'),
                inprogress: document.getElementById('inprogress-column-wrapper'),
                done: document.getElementById('done-column-wrapper')
            };
            columnElements = document.querySelectorAll('.kanban-main-column');

            todoCountSpan = document.getElementById('todo-count');
            inprogressCountSpan = document.getElementById('inprogress-count');
            doneCountSpan = document.getElementById('done-count');

            viewArchivedBtnDesktop = document.getElementById('viewArchivedBtnDesktop');
            viewArchivedBtnMobile = document.getElementById('viewArchivedBtnMobile');
            archivedTasksModal = document.getElementById('archivedTasksModal');
            closeArchivedModalBtn = document.getElementById('closeArchivedModalBtn');
            archivedTasksList = document.getElementById('archivedTasksList');

            moveTaskBottomSheet = document.getElementById('moveTaskBottomSheet');
            bottomSheetOverlay = document.getElementById('bottomSheetOverlay');
            bottomSheetOptionsList = document.getElementById('bottomSheetOptionsList');
            bottomSheetCloseBtn = document.getElementById('bottomSheetCloseBtn');

            kanbanTabsContainer = document.getElementById('kanbanTabs');

            confettiCanvas = document.getElementById('confettiCanvas');
            if (confettiCanvas) {
                 confettiCtx = confettiCanvas.getContext('2d');
            }

            if (loginBtn) loginBtn.addEventListener('click', async () => {
                const email = emailInput.value;
                const password = passwordInput.value;
                authError.textContent = '';
                try { await signInWithEmailAndPassword(auth, email, password); }
                catch (error) { authError.textContent = "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i: " + error.message; }
            });
            if (logoutBtn) logoutBtn.addEventListener('click', async () => {
                try { await signOut(auth); }
                catch (error) { console.error("Error signing out: ", error); }
            });
            if (showRegisterBtn) showRegisterBtn.addEventListener('click', () => showRegisterForm());
            if (showLoginBtn) showLoginBtn.addEventListener('click', () => showLoginForm());
            if (registerBtn) registerBtn.addEventListener('click', async () => {
                const email = registerEmailInput.value;
                const password = registerPasswordInput.value;
                registerAuthError.textContent = '';
                try { await createUserWithEmailAndPassword(auth, email, password); }
                catch (error) { registerAuthError.textContent = "ƒêƒÉng k√Ω th·∫•t b·∫°i: " + error.message; }
            });

            if (taskAttachmentInput) taskAttachmentInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        attachmentPreview.src = e.target.result;
                        attachmentPreview.style.display = 'block';
                    }
                    reader.readAsDataURL(file);
                } else {
                    attachmentPreview.style.display = 'none';
                    attachmentPreview.src = '#';
                }
            });
            if (removeAttachmentBtn) removeAttachmentBtn.addEventListener('click', async () => {
                 if (currentEditTaskId && currentTaskDataForEdit && currentTaskDataForEdit.attachmentPath) {
                    if (await showCustomConfirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a file ƒë√≠nh k√®m n√†y kh√¥ng?")) {
                        uploadSpinner.style.display = 'inline-block';
                        saveTaskBtn.disabled = true;
                        try {
                            const oldFileRef = storageRef(storage, currentTaskDataForEdit.attachmentPath);
                            await deleteObject(oldFileRef);
                            const tasksCollectionPath = getTasksCollectionPath();
                            const taskRefFirestore = doc(db, tasksCollectionPath, currentEditTaskId);
                            await updateDoc(taskRefFirestore, {
                                attachmentURL: null, attachmentPath: null,
                                attachmentType: null, attachmentName: null
                            });
                            currentAttachmentInfo.style.display = 'none';
                            attachmentPreview.style.display = 'none';
                            attachmentPreview.src = '#';
                            if(currentTaskDataForEdit) {
                                currentTaskDataForEdit.attachmentPath = null;
                                currentTaskDataForEdit.attachmentURL = null;
                            }
                            taskAttachmentInput.value = "";
                        } catch (error) {
                            alert("L·ªói khi x√≥a file ƒë√≠nh k√®m: " + error.message);
                        } finally {
                            uploadSpinner.style.display = 'none';
                            saveTaskBtn.disabled = false;
                        }
                    }
                }
            });
            if (saveTaskBtn) saveTaskBtn.addEventListener('click', handleSaveTask);

            [taskInput, taskDueDateInput, taskPriorityInput].forEach(inputElement => {
                if (inputElement) inputElement.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); handleSaveTask();
                    }
                });
            });

            columnElements.forEach(column => {
                if (column) {
                    column.addEventListener('dragover', (e) => e.preventDefault());
                    column.addEventListener('dragenter', (e) => e.target.closest('.kanban-main-column')?.classList.add('drag-over'));
                    column.addEventListener('dragleave', (e) => e.target.closest('.kanban-main-column')?.classList.remove('drag-over'));
                    column.addEventListener('drop', handleDrop);
                }
            });

            if(addTaskBtn) addTaskBtn.addEventListener('click', () => openTaskModal());
            if(fabAddTaskBtn) fabAddTaskBtn.addEventListener('click', () => openTaskModal());

            if(closeModalBtn) closeModalBtn.addEventListener('click', closeAndResetModal);
            window.addEventListener('click', (event) => {
                if (taskModal && event.target == taskModal) closeAndResetModal();
                if (archivedTasksModal && event.target == archivedTasksModal) {
                    archivedTasksModal.style.display = 'none';
                }
                 if (moveTaskBottomSheet && event.target == bottomSheetOverlay) {
                    closeMoveTaskBottomSheet();
                }
            });
            window.addEventListener('resize', () => {
                resizeConfettiCanvas();
                if (isAuthReady && window.innerWidth < 768) {
                    setActiveTab(currentActiveMobileTabStatus); // Re-apply tab logic for current active tab
                } else if (isAuthReady && window.innerWidth >= 768) {
                     Object.values(columnWrappers).forEach(wrapper => {
                        if(wrapper) wrapper.classList.remove('hidden', 'active-column-mobile');
                    });
                }
            });

            if (viewArchivedBtnDesktop) viewArchivedBtnDesktop.addEventListener('click', loadAndShowArchivedTasks);
            if (viewArchivedBtnMobile) viewArchivedBtnMobile.addEventListener('click', loadAndShowArchivedTasks);
            if (closeArchivedModalBtn) closeArchivedModalBtn.addEventListener('click', () => {
                if(archivedTasksModal) archivedTasksModal.style.display = 'none';
            });
            if (bottomSheetCloseBtn) bottomSheetCloseBtn.addEventListener('click', closeMoveTaskBottomSheet);

            if (kanbanTabsContainer) {
                tabButtons = Array.from(kanbanTabsContainer.querySelectorAll('.tab-button'));
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => setActiveTab(button.dataset.status));
                });
            }

            // Initialize swipe listeners for appContent
            if (appContent) {
                appContent.addEventListener('touchstart', handleTouchStart, { passive: true });
                appContent.addEventListener('touchmove', handleTouchMove, { passive: false }); // We might preventDefault
                appContent.addEventListener('touchend', handleTouchEnd, { passive: true });
            }

            resizeConfettiCanvas();
        }
        document.addEventListener('DOMContentLoaded', initializeDOMReferencesAndEvents);

        function showLoginForm() {
            if (loginFormContainer) loginFormContainer.style.display = 'block';
            if (registerFormContainer) registerFormContainer.style.display = 'none';
            if (appHeader) appHeader.style.display = 'none';
            if (appContentContainer) appContentContainer.style.display = 'none';
        }

        function showRegisterForm() {
            if (loginFormContainer) loginFormContainer.style.display = 'none';
            if (registerFormContainer) registerFormContainer.style.display = 'block';
            if (appHeader) appHeader.style.display = 'none';
            if (appContentContainer) appContentContainer.style.display = 'none';
        }

        function showAppContent(user) {
            if (loginFormContainer) loginFormContainer.style.display = 'none';
            if (registerFormContainer) registerFormContainer.style.display = 'none';
            if (appHeader) appHeader.style.display = 'flex';
            if (appContentContainer) appContentContainer.style.display = 'block';

            if (logoutBtn) logoutBtn.classList.remove('hidden');

            if (window.innerWidth < 768) { // md breakpoint
                setActiveTab(currentActiveMobileTabStatus); // Use current or default 'todo'
            } else {
                Object.values(columnWrappers).forEach(wrapper => {
                    if(wrapper) {
                        wrapper.classList.remove('hidden', 'active-column-mobile');
                    }
                });
                 if (kanbanTabsContainer) kanbanTabsContainer.classList.add('md:hidden');
            }
        }

        function setActiveTab(status) {
            if (!status || !tabButtons.length || !Object.keys(columnWrappers).length) return;
            currentActiveMobileTabStatus = status; // Keep track of the active tab

            tabButtons.forEach(button => {
                const buttonStatus = button.dataset.status;

                // Remove all potentially existing color classes from all configs
                Object.values(tabColorConfigs).forEach(config => {
                    button.classList.remove(config.bg, config.text);
                });
                button.classList.remove(inactiveTabConfig.bg, inactiveTabConfig.text);
                button.classList.remove('font-semibold'); // Remove bold if it was there

                if (buttonStatus === status) { // This is the active tab
                    button.classList.add(tabColorConfigs[status].bg, tabColorConfigs[status].text);
                    button.classList.add('font-semibold'); // Make active tab text bolder
                } else { // This is an inactive tab
                    button.classList.add(inactiveTabConfig.bg, inactiveTabConfig.text);
                    // Ensure font-medium or font-normal if active was semibold
                    // button.classList.add('font-medium'); // Assuming base is font-medium (500)
                }
            });

            // Show/hide columns on mobile
            Object.values(columnWrappers).forEach(wrapper => {
                if (wrapper) {
                    if (wrapper.dataset.status === status) {
                        wrapper.classList.remove('hidden');
                        wrapper.classList.add('active-column-mobile');
                    } else {
                        wrapper.classList.add('hidden');
                        wrapper.classList.remove('active-column-mobile');
                    }
                }
            });
        }


        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUserId = user.uid;
                if (typeof showAppContent === 'function') showAppContent(user);
                isAuthReady = true;
                if (typeof loadTasks === 'function') loadTasks();
            } else {
                currentUserId = null;
                isAuthReady = false;
                if (tasksUnsubscribe) {
                    tasksUnsubscribe();
                    tasksUnsubscribe = null;
                }
                Object.values(columns).forEach(col => { if (col) col.innerHTML = ''; });
                if (typeof showLoginForm === 'function') showLoginForm();
            }
        });

        function openTaskModal(taskToEdit = null) {
            currentTaskDataForEdit = taskToEdit ? {...taskToEdit} : null;
            if (attachmentPreview) {
                attachmentPreview.style.display = 'none';
                attachmentPreview.src = '#';
            }
            if (taskAttachmentInput) taskAttachmentInput.value = '';
            if (currentAttachmentInfo) currentAttachmentInfo.style.display = 'none';

            if (taskToEdit) {
                currentEditTaskId = taskToEdit.id;
                if (taskInput) taskInput.value = taskToEdit.description;
                if (taskDueDateInput) taskDueDateInput.value = taskToEdit.dueDate || "";
                if (taskPriorityInput) taskPriorityInput.value = taskToEdit.priority || "medium";
                if (modalTitle) modalTitle.textContent = "S·ª≠a ghi ch√∫";
                if (saveTaskBtn) saveTaskBtn.textContent = "C·∫≠p nh·∫≠t";

                if (taskToEdit.attachmentURL) {
                    if (currentAttachmentLink) {
                        currentAttachmentLink.href = taskToEdit.attachmentURL;
                        currentAttachmentLink.textContent = taskToEdit.attachmentName || "Xem file";
                    }
                    if (currentAttachmentInfo) currentAttachmentInfo.style.display = 'block';
                    if (taskToEdit.attachmentType && taskToEdit.attachmentType.startsWith('image/')) {
                        if (attachmentPreview) {
                            attachmentPreview.src = taskToEdit.attachmentURL;
                            attachmentPreview.style.display = 'block';
                        }
                    }
                }
            } else {
                currentEditTaskId = null;
                if (taskInput) taskInput.value = "";
                if (taskDueDateInput) taskDueDateInput.value = "";
                if (taskPriorityInput) taskPriorityInput.value = "medium";
                if (modalTitle) modalTitle.textContent = "Th√™m ghi ch√∫ m·ªõi";
                if (saveTaskBtn) saveTaskBtn.textContent = "L∆∞u";
            }
            if (taskModal) taskModal.style.display = 'flex';
            if (taskInput) taskInput.focus();
        }

        function closeAndResetModal() {
            if (taskModal) taskModal.style.display = 'none';
            currentEditTaskId = null;
            currentTaskDataForEdit = null;
            if (taskInput) taskInput.value = "";
            if (taskDueDateInput) taskDueDateInput.value = "";
            if (taskPriorityInput) taskPriorityInput.value = "medium";
            if (taskAttachmentInput) taskAttachmentInput.value = "";
            if (attachmentPreview) {
                attachmentPreview.style.display = 'none';
                attachmentPreview.src = '#';
            }
            if (currentAttachmentInfo) currentAttachmentInfo.style.display = 'none';
            if (modalTitle) modalTitle.textContent = "Th√™m ghi ch√∫ m·ªõi";
            if (saveTaskBtn) saveTaskBtn.textContent = "L∆∞u";
        }

        async function handleSaveTask() {
            const description = taskInput.value;
            const dueDate = taskDueDateInput.value;
            const priority = taskPriorityInput.value;
            const file = taskAttachmentInput.files[0];

            if (!description.trim()) {
                alert("N·ªôi dung ghi ch√∫ kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng."); return;
            }
            if (!isAuthReady || !currentUserId) {
                alert("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p."); return;
            }
            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) return;

            if (uploadSpinner) uploadSpinner.style.display = 'inline-block';
            if (saveTaskBtn) saveTaskBtn.disabled = true;

            const taskDataToSave = {
                description: description,
                dueDate: dueDate || null,
                priority: priority,
            };

            try {
                if (file) {
                    if (currentEditTaskId && currentTaskDataForEdit && currentTaskDataForEdit.attachmentPath) {
                        try {
                            const oldFileRef = storageRef(storage, currentTaskDataForEdit.attachmentPath);
                            await deleteObject(oldFileRef);
                        } catch (delError) { console.warn("Could not delete old attachment:", delError); }
                    }
                    const uniqueFileName = `${Date.now()}-${file.name.replace(/\s+/g, '_')}`;
                    const filePath = `users/${currentUserId}/attachments/${uniqueFileName}`;
                    const fileRef = storageRef(storage, filePath);
                    await uploadBytes(fileRef, file);
                    const downloadURL = await getDownloadURL(fileRef);
                    taskDataToSave.attachmentURL = downloadURL;
                    taskDataToSave.attachmentPath = filePath;
                    taskDataToSave.attachmentType = file.type;
                    taskDataToSave.attachmentName = file.name;
                } else if (currentEditTaskId && currentTaskDataForEdit) {
                    if (currentTaskDataForEdit.attachmentURL !== undefined) taskDataToSave.attachmentURL = currentTaskDataForEdit.attachmentURL;
                    if (currentTaskDataForEdit.attachmentPath !== undefined) taskDataToSave.attachmentPath = currentTaskDataForEdit.attachmentPath;
                    if (currentTaskDataForEdit.attachmentType !== undefined) taskDataToSave.attachmentType = currentTaskDataForEdit.attachmentType;
                    if (currentTaskDataForEdit.attachmentName !== undefined) taskDataToSave.attachmentName = currentTaskDataForEdit.attachmentName;
                }


                if (currentEditTaskId) {
                    const taskRefFirestore = doc(db, tasksCollectionPath, currentEditTaskId);
                    await updateDoc(taskRefFirestore, taskDataToSave);
                } else {
                    taskDataToSave.status = 'todo';
                    taskDataToSave.userId = currentUserId;
                    taskDataToSave.createdAt = Timestamp.now();
                    taskDataToSave.order = Date.now();
                    await addDoc(collection(db, tasksCollectionPath), taskDataToSave);
                }
                closeAndResetModal();
            } catch (error) {
                alert("L·ªói khi l∆∞u ghi ch√∫: " + error.message);
            } finally {
                if (uploadSpinner) uploadSpinner.style.display = 'none';
                if (saveTaskBtn) saveTaskBtn.disabled = false;
            }
        }

        async function moveTask(taskId, newStatus) {
            if (!isAuthReady || !currentUserId) return;
            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) return;
            const taskRef = doc(db, tasksCollectionPath, taskId);
            try {
                await updateDoc(taskRef, { status: newStatus, order: Date.now() });
                if (newStatus === 'done') triggerConfetti();
            } catch (error) {
                alert("L·ªói khi di chuy·ªÉn ghi ch√∫: " + error.message);
            }
        }

        async function archiveTask(taskId) {
            if (!isAuthReady || !currentUserId) {
                alert("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ th·ª±c hi·ªán h√†nh ƒë·ªông n√†y.");
                return;
            }
            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) return;

            const taskRef = doc(db, tasksCollectionPath, taskId);
            try {
                await updateDoc(taskRef, {
                    status: 'archived',
                    order: Date.now()
                });
                console.log(`Task ${taskId} archived.`);
            } catch (error) {
                alert("L·ªói khi l∆∞u tr·ªØ ghi ch√∫: " + error.message);
            }
        }

        async function unarchiveTask(taskId) {
            if (!isAuthReady || !currentUserId) {
                alert("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p."); return;
            }
            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) return;
            const taskRef = doc(db, tasksCollectionPath, taskId);
            try {
                await updateDoc(taskRef, {
                    status: 'todo',
                    order: Date.now()
                });
                console.log(`Task ${taskId} unarchived.`);
                loadAndShowArchivedTasks();
            } catch (error) {
                alert("L·ªói khi kh√¥i ph·ª•c ghi ch√∫: " + error.message);
            }
        }

        async function deleteArchivedTaskPermanently(taskId, attachmentPath) {
            if (!isAuthReady || !currentUserId) {
                alert("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p."); return;
            }
            if (await showCustomConfirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA Vƒ®NH VI·ªÑN ghi ch√∫ n√†y kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.")) {
                const tasksCollectionPath = getTasksCollectionPath();
                if (!tasksCollectionPath) return;

                if (attachmentPath) {
                    const fileRef = storageRef(storage, attachmentPath);
                    try { await deleteObject(fileRef); console.log("Archived attachment deleted."); }
                    catch (error) { console.error("Error deleting archived attachment:", error); }
                }
                try {
                    await deleteDoc(doc(db, tasksCollectionPath, taskId));
                    console.log("Archived task permanently deleted.");
                    loadAndShowArchivedTasks();
                }
                catch (error) { alert("L·ªói khi x√≥a vƒ©nh vi·ªÖn ghi ch√∫: " + error.message); }
            }
        }


        function renderArchivedTaskItem(task) {
            const item = document.createElement('div');
            item.classList.add('archived-task-item');

            const descriptionP = document.createElement('p');
            descriptionP.textContent = task.description;
            if (task.attachmentName) {
                descriptionP.textContent += ` (ƒê√≠nh k√®m: ${task.attachmentName})`;
            }
            item.appendChild(descriptionP);

            const actionsDiv = document.createElement('div');
            actionsDiv.classList.add('actions');

            const unarchiveButton = document.createElement('button');
            unarchiveButton.textContent = 'Kh√¥i ph·ª•c';
            unarchiveButton.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'py-1', 'px-2', 'rounded');
            unarchiveButton.onclick = () => unarchiveTask(task.id);
            actionsDiv.appendChild(unarchiveButton);

            const deletePermButton = document.createElement('button');
            deletePermButton.textContent = 'X√≥a V.V.';
            deletePermButton.classList.add('bg-red-500', 'hover:bg-red-600', 'text-white', 'py-1', 'px-2', 'rounded');
            deletePermButton.onclick = () => deleteArchivedTaskPermanently(task.id, task.attachmentPath);
            actionsDiv.appendChild(deletePermButton);

            item.appendChild(actionsDiv);
            return item;
        }

        async function loadAndShowArchivedTasks() {
            if (!isAuthReady || !currentUserId) {
                alert("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p."); return;
            }
            if (!archivedTasksList || !archivedTasksModal) return;

            archivedTasksList.innerHTML = '<p class="text-center text-slate-500">ƒêang t·∫£i...</p>';
            archivedTasksModal.style.display = 'flex';

            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) {
                 archivedTasksList.innerHTML = '<p class="text-center text-red-500">L·ªói: Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ªùng d·∫´n d·ªØ li·ªáu.</p>';
                return;
            }

            try {
                const q = query(collection(db, tasksCollectionPath),
                                where("userId", "==", currentUserId),
                                where("status", "==", "archived"),
                                orderBy("order", "desc"));
                const snapshot = await getDocs(q);

                archivedTasksList.innerHTML = '';
                if (snapshot.empty) {
                    archivedTasksList.innerHTML = '<p class="text-center text-slate-500">Kh√¥ng c√≥ ghi ch√∫ n√†o ƒë∆∞·ª£c l∆∞u tr·ªØ.</p>';
                    return;
                }
                snapshot.forEach(docSnap => {
                    const taskData = { id: docSnap.id, ...docSnap.data() };
                    const taskItemElement = renderArchivedTaskItem(taskData);
                    archivedTasksList.appendChild(taskItemElement);
                });

            } catch (error) {
                console.error("Error loading archived tasks:", error);
                archivedTasksList.innerHTML = `<p class="text-center text-red-500">L·ªói khi t·∫£i danh s√°ch l∆∞u tr·ªØ: ${error.message}</p>`;
            }
        }


        function loadTasks() {
             if (!isAuthReady || !currentUserId) return;
            if (tasksUnsubscribe) tasksUnsubscribe();

            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) {
                console.error("Cannot load tasks: tasksCollectionPath is null.");
                return;
            }

            const q = query(collection(db, tasksCollectionPath),
                            where("userId", "==", currentUserId),
                            where("status", "in", ["todo", "inprogress", "done"]),
                            orderBy("order", "asc"));

            tasksUnsubscribe = onSnapshot(q, (snapshot) => {
                let taskCounts = { todo: 0, inprogress: 0, done: 0 };
                if (columns.todo) columns.todo.innerHTML = '';
                if (columns.inprogress) columns.inprogress.innerHTML = '';
                if (columns.done) columns.done.innerHTML = '';

                snapshot.forEach((docSnap) => {
                    const taskData = { id: docSnap.id, ...docSnap.data() };
                    if (["todo", "inprogress", "done"].includes(taskData.status)) {
                        renderTask(taskData);
                        if (taskCounts.hasOwnProperty(taskData.status)) {
                            taskCounts[taskData.status]++;
                        }
                    }
                });

                if(todoCountSpan) todoCountSpan.textContent = taskCounts.todo;
                if(inprogressCountSpan) inprogressCountSpan.textContent = taskCounts.inprogress;
                if(doneCountSpan) doneCountSpan.textContent = taskCounts.done;

                Object.entries(columns).forEach(([statusKey, columnTaskListDiv]) => {
                    const columnWrapper = columnWrappers[statusKey];
                    if (columnTaskListDiv && columnTaskListDiv.children.length === 0) {
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('empty-column-placeholder');
                        const iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" /></svg>`;
                        placeholder.innerHTML = iconSvg;
                        const messageP = document.createElement('p');
                        let message = "K√©o ghi ch√∫ v√†o ƒë√¢y";
                        if (statusKey === 'todo') message = "Ch∆∞a c√≥ ghi ch√∫ n√†o. Nh·∫•n '+' ƒë·ªÉ th√™m.";
                        else if (statusKey === 'inprogress') message = "Kh√¥ng c√≥ ghi ch√∫ n√†o ƒëang th·ª±c hi·ªán.";
                        else if (statusKey === 'done') message = "Ch∆∞a c√≥ ghi ch√∫ n√†o ho√†n th√†nh.";
                        messageP.textContent = message;
                        placeholder.appendChild(messageP);
                        columnTaskListDiv.appendChild(placeholder);
                    }
                });
                 const firestoreErrorElement = document.querySelector('.firestore-error');
                if (firestoreErrorElement) firestoreErrorElement.remove();
            }, (error) => console.error(`Error loading tasks: `, error));
        }

        function renderTask(task) {
            const taskElement = document.createElement('div');
            taskElement.classList.add('task', 'bg-white', 'p-3', 'rounded-md', 'shadow', 'hover:shadow-lg', 'transition-shadow', 'flex', 'flex-col', 'items-start');
            taskElement.setAttribute('draggable', true);
            taskElement.dataset.id = task.id;
            taskElement.dataset.status = task.status;
            taskElement.dataset.order = task.order;

            if (task.priority) taskElement.classList.add(`priority-${task.priority}`);
            else taskElement.classList.add('priority-medium');

            const mainContent = document.createElement('div');
            mainContent.classList.add('w-full', 'flex', 'justify-between', 'items-center', 'mb-1');

            const taskText = document.createElement('p');
            taskText.textContent = task.description;
            taskText.classList.add('text-sm', 'text-slate-700', 'flex-grow', 'mr-2');
            mainContent.appendChild(taskText);

            const actionsContainer = document.createElement('div');
            actionsContainer.classList.add('task-actions', 'flex', 'items-center', 'flex-shrink-0');

            const editButton = document.createElement('button');
            editButton.innerHTML = iconEdit;
            editButton.classList.add('edit-btn');
            editButton.title = "S·ª≠a ghi ch√∫";
            editButton.onclick = (e) => { e.stopPropagation(); openTaskModal(task); };
            actionsContainer.appendChild(editButton);

            const deleteButton = document.createElement('button');
            deleteButton.innerHTML = iconDelete;
            deleteButton.classList.add('delete-btn');
            deleteButton.title = "X√≥a ghi ch√∫";
            deleteButton.onclick = async (e) => {
                e.stopPropagation();
                if (await showCustomConfirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a ghi ch√∫ n√†y kh√¥ng?")) {
                    deleteTask(task.id, task.attachmentPath);
                }
            };
            actionsContainer.appendChild(deleteButton);

            const moreActionsButton = document.createElement('button');
            moreActionsButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512" fill="currentColor" style="width:0.7em; height:0.7em; display:inline-block; vertical-align:middle;"><path d="M64 360a56 56 0 100 112 56 56 0 100-112zm0-160a56 56 0 100 112 56 56 0 100-112zM120 96a56 56 0 10-112 0 56 56 0 10112 0z"/></svg>`;
            moreActionsButton.classList.add('text-slate-500', 'hover:text-slate-700');
            moreActionsButton.title = "Th√™m h√†nh ƒë·ªông";
            moreActionsButton.onclick = (e) => {
                e.stopPropagation();
                openMoveTaskBottomSheet(task.id, task.status);
            };
            actionsContainer.appendChild(moreActionsButton);

            mainContent.appendChild(actionsContainer);
            taskElement.appendChild(mainContent);

            if (task.attachmentURL) {
                if (task.attachmentType && task.attachmentType.startsWith('image/')) {
                    const imgPreview = document.createElement('img');
                    imgPreview.src = task.attachmentURL;
                    imgPreview.alt = task.attachmentName || "·∫¢nh ƒë√≠nh k√®m";
                    imgPreview.classList.add('task-attachment-preview');
                    taskElement.appendChild(imgPreview);
                } else {
                    const fileLink = document.createElement('a');
                    fileLink.href = task.attachmentURL;
                    fileLink.textContent = task.attachmentName || "Xem file ƒë√≠nh k√®m";
                    fileLink.target = "_blank";
                    fileLink.classList.add('task-attachment-link');
                    taskElement.appendChild(fileLink);
                }
            }

            const detailsContainer = document.createElement('div');
            detailsContainer.classList.add('w-full', 'flex', 'justify-between', 'items-center', 'flex-wrap', 'mb-1', 'mt-1');

            if (task.dueDate) {
                const dueDateElement = document.createElement('p');
                const [year, month, day] = task.dueDate.split('-');
                const formattedDate = `${day}/${month}/${year}`;
                dueDateElement.textContent = `H·∫°n: ${formattedDate}`;
                dueDateElement.classList.add('task-due-date', 'mr-2');
                const today = new Date(); today.setHours(0, 0, 0, 0);
                const dueDateObj = new Date(year, month - 1, day);
                if (dueDateObj < today) {
                    dueDateElement.classList.add('due-date-passed');
                    dueDateElement.textContent += " (Qu√° h·∫°n)";
                } else if (dueDateObj.getTime() === today.getTime()) {
                    dueDateElement.classList.add('due-date-today');
                    dueDateElement.textContent += " (H√¥m nay)";
                }
                detailsContainer.appendChild(dueDateElement);
            }

            if (task.priority) {
                const priorityIndicator = document.createElement('span');
                priorityIndicator.classList.add('priority-indicator', `indicator-${task.priority}`);
                priorityIndicator.textContent = task.priority === 'high' ? 'Cao' : task.priority === 'medium' ? 'TB' : 'Th·∫•p';
                detailsContainer.appendChild(priorityIndicator);
            }

            if (detailsContainer.hasChildNodes()) taskElement.appendChild(detailsContainer);

            const moveActionsContainer = document.createElement('div');
            moveActionsContainer.classList.add('task-move-actions');

            if (task.status !== 'todo') {
                const moveToTodoBtn = document.createElement('button');
                moveToTodoBtn.innerHTML = iconArrowLeft;
                moveToTodoBtn.classList.add('move-btn-todo');
                moveToTodoBtn.title = "Chuy·ªÉn sang C·∫ßn l√†m";
                moveToTodoBtn.onclick = (e) => { e.stopPropagation(); moveTask(task.id, 'todo'); };
                moveActionsContainer.appendChild(moveToTodoBtn);
            }
            if (task.status !== 'inprogress') {
                const moveToInProgressBtn = document.createElement('button');
                moveToInProgressBtn.innerHTML = (task.status === 'todo') ? iconArrowRight : iconArrowLeft;
                moveToInProgressBtn.classList.add('move-btn-inprogress');
                moveToInProgressBtn.title = "Chuy·ªÉn sang ƒêang l√†m";
                moveToInProgressBtn.onclick = (e) => { e.stopPropagation(); moveTask(task.id, 'inprogress'); };
                moveActionsContainer.appendChild(moveToInProgressBtn);
            }

            if (task.status === 'done') {
                const archiveBtn = document.createElement('button');
                archiveBtn.innerHTML = iconArchive;
                archiveBtn.classList.add('archive-btn');
                archiveBtn.title = "L∆∞u tr·ªØ ghi ch√∫";
                archiveBtn.onclick = (e) => { e.stopPropagation(); archiveTask(task.id); };
                moveActionsContainer.appendChild(archiveBtn);
            } else if (task.status !== 'done') {
                const moveToDoneBtn = document.createElement('button');
                moveToDoneBtn.innerHTML = iconCheck;
                moveToDoneBtn.classList.add('move-btn-done');
                moveToDoneBtn.title = "Chuy·ªÉn sang Ho√†n th√†nh";
                moveToDoneBtn.onclick = (e) => { e.stopPropagation(); moveTask(task.id, 'done'); };
                moveActionsContainer.appendChild(moveToDoneBtn);
            }

            if (moveActionsContainer.hasChildNodes()) taskElement.appendChild(moveActionsContainer);

            taskElement.addEventListener('dragstart', handleDragStart);
            if (columns[task.status]) columns[task.status].appendChild(taskElement);
            else if (columns.todo) columns.todo.appendChild(taskElement);
        }

        async function deleteTask(taskId, attachmentPath) {
            if (!isAuthReady || !currentUserId) { alert("B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p ƒë·ªÉ x√≥a ghi ch√∫."); return; }
            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) return;

            if (attachmentPath) {
                const fileRef = storageRef(storage, attachmentPath);
                try { await deleteObject(fileRef); }
                catch (error) { console.error("Error deleting attachment from Storage:", error); }
            }
            try { await deleteDoc(doc(db, tasksCollectionPath, taskId)); }
            catch (error) { alert("L·ªói khi x√≥a ghi ch√∫ kh·ªèi Firestore: " + error.message); }
        }

        let draggedItem = null;
        function handleDragStart(event) {
            if (!event.target.classList.contains('task')) return;
            draggedItem = event.target;
            event.dataTransfer.setData('text/plain', event.target.dataset.id);
            setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0);
        }

        async function handleDrop(event) {
            event.preventDefault();
            const targetColumnWrapper = event.target.closest('.kanban-main-column');
            if (!targetColumnWrapper || !draggedItem) return;

            targetColumnWrapper.classList.remove('drag-over');
            const draggedItemId = draggedItem.dataset.id;
            const originalStatus = draggedItem.dataset.status;
            const newStatus = targetColumnWrapper.dataset.status;

            draggedItem.classList.remove('dragging');
            let newOrder;

            const tasksCollectionPath = getTasksCollectionPath();
            if (!tasksCollectionPath) { draggedItem = null; return; }
            const taskRef = doc(db, tasksCollectionPath, draggedItemId);

            if (originalStatus === newStatus) {
                const mouseY = event.clientY;
                let nextSibling = null;
                const currentColumnTasksDiv = columns[newStatus];

                for (const child of currentColumnTasksDiv.children) {
                    if (child === draggedItem || !child.classList.contains('task')) continue;
                    const rect = child.getBoundingClientRect();
                    if (mouseY < rect.top + rect.height / 2) {
                        nextSibling = child;
                        break;
                    }
                }

                if (nextSibling) {
                    const orderOfNextSibling = parseFloat(nextSibling.dataset.order);
                    let orderOfPrevSibling = 0;
                    let tempPrev = nextSibling.previousElementSibling;
                    while(tempPrev && (tempPrev === draggedItem || !tempPrev.classList.contains('task'))) {
                        tempPrev = tempPrev.previousElementSibling;
                    }
                    if (tempPrev) {
                         orderOfPrevSibling = parseFloat(tempPrev.dataset.order);
                    } else {
                        orderOfPrevSibling = orderOfNextSibling - 2000;
                    }
                    newOrder = (orderOfPrevSibling + orderOfNextSibling) / 2;
                } else {
                    const allTasksInColumn = Array.from(currentColumnTasksDiv.children)
                                               .filter(el => el.classList.contains('task') && el !== draggedItem)
                                               .map(el => parseFloat(el.dataset.order))
                                               .sort((a,b) => a - b);
                    if (allTasksInColumn.length > 0) {
                        newOrder = allTasksInColumn[allTasksInColumn.length - 1] + 1000;
                    } else {
                        newOrder = Date.now();
                    }
                }
                await updateDoc(taskRef, { order: newOrder });
            } else {
                newOrder = Date.now();
                await updateDoc(taskRef, { status: newStatus, order: newOrder });
                if (newStatus === 'done') triggerConfetti();
            }
            draggedItem = null;
        }

        function openMoveTaskBottomSheet(taskId, currentStatus) {
            activeBottomSheetTaskId = taskId;
            if (!bottomSheetOptionsList || !moveTaskBottomSheet || !bottomSheetOverlay) return;

            bottomSheetOptionsList.innerHTML = '';

            const destinations = [
                { id: 'todo', name: 'C·∫ßn l√†m' },
                { id: 'inprogress', name: 'ƒêang l√†m' },
                { id: 'done', name: 'Ho√†n th√†nh' }
            ];

            if (currentStatus === 'done') {
                destinations.push({id: 'archived', name: 'L∆∞u tr·ªØ'});
            }

            destinations.forEach(dest => {
                if (dest.id !== currentStatus) {
                    const button = document.createElement('button');
                    button.textContent = dest.name;
                    button.onclick = async () => {
                        if (activeBottomSheetTaskId) {
                            if (dest.id === 'archived') {
                                await archiveTask(activeBottomSheetTaskId);
                            } else {
                                await moveTask(activeBottomSheetTaskId, dest.id);
                            }
                        }
                        closeMoveTaskBottomSheet();
                    };
                    bottomSheetOptionsList.appendChild(button);
                }
            });

            moveTaskBottomSheet.classList.add('active');
            bottomSheetOverlay.classList.add('active');
        }

        function closeMoveTaskBottomSheet() {
            if (moveTaskBottomSheet) moveTaskBottomSheet.classList.remove('active');
            if (bottomSheetOverlay) bottomSheetOverlay.classList.remove('active');
            activeBottomSheetTaskId = null;
        }

        function resizeConfettiCanvas() {
            if(confettiCanvas) {
                confettiCanvas.width = window.innerWidth;
                confettiCanvas.height = window.innerHeight;
            }
        }

        function ConfettiParticle(x, y) {
            this.x = x; this.y = y; this.size = Math.random() * 7 + 3;
            this.speedX = Math.random() * 6 - 3; this.speedY = Math.random() * -15 - 5;
            if (typeof confettiColors === 'undefined' || !Array.isArray(confettiColors) || confettiColors.length === 0) {
                this.color = '#000000';
            } else {
                this.color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
            }
            this.opacity = 1; this.angle = Math.random() * Math.PI * 2;
            this.spin = Math.random() * 0.4 - 0.2; this.gravity = 0.3; this.drag = 0.98;
        }
        ConfettiParticle.prototype.update = function() {
            this.speedY += this.gravity; this.speedX *= this.drag; this.x += this.speedX; this.y += this.speedY;
            this.angle += this.spin; this.opacity -= 0.01;
        };
        ConfettiParticle.prototype.draw = function() {
            if(!confettiCtx) return;
            confettiCtx.save(); confettiCtx.globalAlpha = this.opacity;
            confettiCtx.translate(this.x + this.size / 2, this.y + this.size / 2);
            confettiCtx.rotate(this.angle); confettiCtx.fillStyle = this.color;
            confettiCtx.fillRect(-this.size /2, -this.size /2, this.size, this.size * 1.5);
            confettiCtx.restore();
        };
        function createConfettiBurst() {
            confettiParticles = [];
            const particleCount = 150;
            if(!confettiCanvas) return;
            const centerX = confettiCanvas.width / 2; const centerY = confettiCanvas.height / 2;
            for (let i = 0; i < particleCount; i++) {
                confettiParticles.push(new ConfettiParticle(centerX + (Math.random() - 0.5) * (confettiCanvas.width * 0.8), centerY + (Math.random() - 0.5) * (confettiCanvas.height * 0.6)));
            }
        }
        let confettiAnimationId = null;
        function animateConfetti() {
            if(!confettiCtx || !confettiCanvas) return;
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            let stillAlive = false;
            for (let i = confettiParticles.length - 1; i >= 0; i--) {
                const p = confettiParticles[i]; p.update(); p.draw();
                if (p.opacity > 0 && p.y < confettiCanvas.height) stillAlive = true;
                else confettiParticles.splice(i, 1);
            }
            if (stillAlive) confettiAnimationId = requestAnimationFrame(animateConfetti);
            else {
                if(confettiCtx && confettiCanvas) confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null;
            }
        }
        function triggerConfetti() {
            if (confettiAnimationId) cancelAnimationFrame(confettiAnimationId);
            createConfettiBurst(); animateConfetti();
        }

        function showCustomConfirm(message) {
            return new Promise((resolve) => {
                const confirmModal = document.createElement('div');
                confirmModal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 2000;`;
                const confirmContent = document.createElement('div');
                confirmContent.style.cssText = `background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); text-align: center; width: 90%; max-width: 350px;`;
                const messageP = document.createElement('p');
                messageP.textContent = message; messageP.style.cssText = 'margin-bottom: 20px; font-size: 1.1rem; color: #333;';
                const yesButton = document.createElement('button'); yesButton.textContent = 'C√≥';
                yesButton.style.cssText = `background-color: #ef4444; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px; font-weight: 500; transition: background-color 0.2s;`;
                const noButton = document.createElement('button'); noButton.textContent = 'Kh√¥ng';
                noButton.style.cssText = `background-color: #6b7280; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: 500; transition: background-color 0.2s;`;
                yesButton.onmouseover = () => yesButton.style.backgroundColor = '#dc2626'; yesButton.onmouseout = () => yesButton.style.backgroundColor = '#ef4444';
                noButton.onmouseover = () => noButton.style.backgroundColor = '#4b5563'; noButton.onmouseout = () => noButton.style.backgroundColor = '#6b7280';
                const closeConfirm = (result) => { document.body.removeChild(confirmModal); resolve(result); };
                yesButton.onclick = () => closeConfirm(true); noButton.onclick = () => closeConfirm(false);
                confirmContent.appendChild(messageP); confirmContent.appendChild(yesButton); confirmContent.appendChild(noButton);
                confirmModal.appendChild(confirmContent); document.body.appendChild(confirmModal);
            });
        }

        // Swipe gesture handlers
        function handleTouchStart(evt) {
            if (window.innerWidth >= 768) return; // Only on mobile
            touchStartX = evt.touches[0].clientX;
            touchStartY = evt.touches[0].clientY;
            touchEndX = touchStartX; // Reset touchEndX for the new touch sequence
        }

        function handleTouchMove(evt) {
            if (window.innerWidth >= 768 || !touchStartX || !touchStartY) return;

            touchEndX = evt.touches[0].clientX; // Continuously update touchEndX
            let currentY = evt.touches[0].clientY;
            let xDiff = touchStartX - touchEndX;
            let yDiff = touchStartY - currentY;

            // If horizontal movement is more significant than vertical,
            // and exceeds a small threshold, prevent default page scroll.
            if (Math.abs(xDiff) > Math.abs(yDiff) && Math.abs(xDiff) > swipeXThresholdForLock) {
                evt.preventDefault();
            }
        }

        function handleTouchEnd() {
            if (window.innerWidth >= 768 || !touchStartX) return; // Check if touchstart was even registered for mobile

            let swipeDistance = touchStartX - touchEndX;

            // Check if the swipe distance exceeds the defined threshold
            if (Math.abs(swipeDistance) > swipeThreshold) {
                const currentIndex = tabOrder.indexOf(currentActiveMobileTabStatus);
                let newIndex = currentIndex;

                if (swipeDistance > 0) { // Swiped left (user wants to see next tab)
                    newIndex = Math.min(currentIndex + 1, tabOrder.length - 1);
                } else { // Swiped right (user wants to see previous tab)
                    newIndex = Math.max(currentIndex - 1, 0);
                }

                if (newIndex !== currentIndex) {
                    setActiveTab(tabOrder[newIndex]);
                }
            }
            // Reset touch coordinates
            touchStartX = 0;
            touchStartY = 0;
            // touchEndX is implicitly reset or not used until next touchmove
        }

    </script>
</body>
</html>
